#!/usr/bin/env bash
#
# Noto Font Fontconfig Installer
# Installs or removes a fontconfig snippet that prioritizes Noto families
# with Thai coverage for sans-serif, serif, and monospace fallbacks.
#

set -euo pipefail

# ============================================================================
# CONSTANTS AND GLOBALS
# ============================================================================

readonly SCRIPT_NAME="$(basename "$0")"
readonly CONFIG_NAME="60-noto-prefer-thai.conf"
readonly LOCK_TIMEOUT=30

readonly REQUIRED_FONTS=(
  "Noto Sans"
  "Noto Sans Thai"
  "Noto Sans Mono"
  "Noto Serif"
  "Noto Serif Thai"
  "Noto Color Emoji"
)

# Exit codes
readonly EXIT_SUCCESS=0
readonly EXIT_GENERAL_ERROR=1
readonly EXIT_PERMISSION_DENIED=2
readonly EXIT_DEPENDENCY_MISSING=3
readonly EXIT_LOCK_FAILED=4
readonly EXIT_VALIDATION_FAILED=5

# Cleanup tracking
declare -a CLEANUP_FILES=()
LOCK_FD=""

# ============================================================================
# LOGGING AND ERROR HANDLING
# ============================================================================

log() {
  printf '[INFO] %s\n' "$*" >&2
}

log_warn() {
  printf '[WARN] %s\n' "$*" >&2
}

log_error() {
  printf '[ERROR] %s\n' "$*" >&2
}

log_debug() {
  if [[ ${DEBUG:-0} -eq 1 ]]; then
    printf '[DEBUG] %s\n' "$*" >&2
  fi
}

die() {
  local exit_code="${1:-$EXIT_GENERAL_ERROR}"
  shift
  log_error "$@"
  exit "$exit_code"
}

# ============================================================================
# CLEANUP AND SIGNAL HANDLING
# ============================================================================

cleanup() {
  local exit_code=$?

  # Remove lock file
  if [[ -n "$LOCK_FD" ]] && [[ -e "/proc/self/fd/$LOCK_FD" ]]; then
    flock -u "$LOCK_FD" 2>/dev/null || true
    eval "exec $LOCK_FD>&-" 2>/dev/null || true
  fi

  # Clean up temporary files
  for file in "${CLEANUP_FILES[@]}"; do
    if [[ -e "$file" ]]; then
      rm -f "$file" 2>/dev/null || true
    fi
  done

  log_debug "Cleanup completed with exit code $exit_code"
}

trap cleanup EXIT
trap 'die $EXIT_GENERAL_ERROR "Interrupted by user"' INT TERM

# ============================================================================
# USAGE AND HELP
# ============================================================================

usage() {
  cat <<USAGE
Usage: $SCRIPT_NAME [options]

Install or remove a fontconfig snippet that prioritizes Noto families for
sans-serif, serif, and monospace fallbacks with Thai coverage.

Options:
  --install           Install or update the configuration (default)
  --remove            Remove the configuration
  --status            Report whether the configuration is active
  --system            Target the system-wide fontconfig directories (default)
  --user              Target the per-user fontconfig directories (~/.config/fontconfig)
  --dry-run           Print intended actions without modifying anything
  --no-cache          Skip running fc-cache after changes
  --force             Overwrite conflicting files instead of aborting
  --no-font-install   Skip checking/auto-installing Noto font packages
  --flatpak           Apply Flatpak override so sandboxed apps see this config (user scope)
  --debug             Enable debug logging
  -h, --help          Show this help message

Examples:
  $SCRIPT_NAME --user --install
  $SCRIPT_NAME --system --remove
  $SCRIPT_NAME --user --dry-run --flatpak
  $SCRIPT_NAME --status --user

Exit Codes:
  0 - Success
  1 - General error
  2 - Permission denied
  3 - Required dependency missing
  4 - Could not acquire lock
  5 - Validation failed

USAGE
}

# ============================================================================
# CONFIGURATION PAYLOAD
# ============================================================================

config_payload() {
  cat <<'XML'
<?xml version='1.0'?>
<!DOCTYPE fontconfig SYSTEM 'urn:fontconfig:fonts.dtd'>
<fontconfig>
 <!-- Prefer Noto for generic families (minimal set) -->
 <alias>
  <family>sans-serif</family>
  <prefer>
   <family>Noto Sans</family>
   <family>Noto Sans Thai</family>
   <family>Noto Color Emoji</family>
  </prefer>
 </alias>
 <alias>
  <family>serif</family>
  <prefer>
   <family>Noto Serif</family>
   <family>Noto Serif Thai</family>
   <family>Noto Color Emoji</family>
  </prefer>
 </alias>
 <alias>
  <family>monospace</family>
  <prefer>
   <family>Noto Sans Mono</family>
   <family>Noto Sans Thai</family>
   <family>Noto Color Emoji</family>
  </prefer>
 </alias>
 <!-- Strong bindings so generic families favor Noto first -->
 <match target="pattern">
  <test name="family" qual="any">
   <string>serif</string>
  </test>
  <edit binding="strong" mode="prepend" name="family">
   <string>Noto Serif</string>
   <string>Noto Serif Thai</string>
  </edit>
 </match>
 <match target="pattern">
  <test name="family" qual="any">
   <string>sans-serif</string>
  </test>
  <edit binding="strong" mode="prepend" name="family">
   <string>Noto Sans</string>
   <string>Noto Sans Thai</string>
  </edit>
 </match>
 <!-- Monospace contexts: make sure Noto covers codepoints -->
 <match target="pattern">
  <test name="family" qual="any">
   <string>monospace</string>
  </test>
  <edit binding="strong" mode="prepend" name="family">
   <string>Noto Sans Mono</string>
   <string>Noto Sans Thai</string>
  </edit>
 </match>
 <dir>~/.local/share/fonts</dir>
</fontconfig>
XML
}

# ============================================================================
# VALIDATION AND DEPENDENCY CHECKS
# ============================================================================

validate_xml() {
  local xml_content="$1"

  # Basic XML structure validation
  if ! echo "$xml_content" | grep -q "<?xml version"; then
    log_error "Invalid XML: missing XML declaration"
    return 1
  fi

  if ! echo "$xml_content" | grep -q "<fontconfig>"; then
    log_error "Invalid XML: missing fontconfig root element"
    return 1
  fi

  # Check if xmllint is available for deeper validation
  if command -v xmllint >/dev/null 2>&1; then
    if ! echo "$xml_content" | xmllint --noout - 2>/dev/null; then
      log_warn "XML validation with xmllint failed, but will proceed"
    else
      log_debug "XML validation passed"
    fi
  fi

  return 0
}

check_command() {
  local cmd="$1"
  local required="${2:-0}"

  if ! command -v "$cmd" >/dev/null 2>&1; then
    if [[ $required -eq 1 ]]; then
      die "$EXIT_DEPENDENCY_MISSING" "Required command '$cmd' not found. Please install it and try again."
    fi
    return 1
  fi
  return 0
}

check_path_safety() {
  local path="$1"

  # Check for null bytes
  if [[ "$path" == *$'\0'* ]]; then
    log_error "Path contains null bytes: $path"
    return 1
  fi

  # Check for path traversal attempts
  if [[ "$path" == *".."* ]]; then
    log_warn "Path contains '..': $path"
  fi

  return 0
}

validate_directory_writable() {
  local dir="$1"
  local dry_run_flag=$2

  if [[ $dry_run_flag -eq 1 ]]; then
    log_debug "Skipping write check in dry-run mode"
    return 0
  fi

  if [[ ! -d "$dir" ]]; then
    log_debug "Directory doesn't exist yet: $dir"
    return 0
  fi

  if [[ ! -w "$dir" ]]; then
    log_error "Directory not writable: $dir"
    return 1
  fi

  return 0
}

# ============================================================================
# LOCK MANAGEMENT
# ============================================================================

acquire_lock() {
  local lock_file="$1"
  local dry_run_flag=$2

  if [[ $dry_run_flag -eq 1 ]]; then
    log_debug "Dry run: skipping lock acquisition"
    return 0
  fi

  local lock_dir
  lock_dir="$(dirname "$lock_file")"

  if [[ ! -d "$lock_dir" ]]; then
    mkdir -p "$lock_dir" || die "$EXIT_GENERAL_ERROR" "Failed to create lock directory: $lock_dir"
  fi

  # Open lock file descriptor
  exec {LOCK_FD}>"$lock_file" || die "$EXIT_LOCK_FAILED" "Failed to open lock file: $lock_file"

  # Try to acquire exclusive lock with timeout
  if ! flock -x -w "$LOCK_TIMEOUT" "$LOCK_FD"; then
    die "$EXIT_LOCK_FAILED" "Could not acquire lock within ${LOCK_TIMEOUT}s. Another instance may be running."
  fi

  log_debug "Lock acquired: $lock_file"
}

# ============================================================================
# PERMISSION CHECKS
# ============================================================================

require_root() {
  if [[ ${EUID:-$(id -u)} -ne 0 ]]; then
    die "$EXIT_PERMISSION_DENIED" "This operation requires root privileges. Re-run with sudo or as root."
  fi
}

# ============================================================================
# BACKUP OPERATIONS
# ============================================================================

maybe_backup() {
  local path="$1"
  local dry_run_flag=$2
  local force_flag=$3

  if [[ ! -e "$path" && ! -L "$path" ]]; then
    return 0
  fi

  if [[ $force_flag -eq 1 ]]; then
    log "Overwriting $path (--force enabled, no backup)."
    return 0
  fi

  local timestamp
  timestamp=$(date +%Y%m%d_%H%M%S)
  local backup="${path}.bak.${timestamp}"

  # Ensure backup path doesn't already exist
  local counter=1
  while [[ -e "$backup" ]]; do
    backup="${path}.bak.${timestamp}.${counter}"
    ((counter++))
    if [[ $counter -gt 100 ]]; then
      die "$EXIT_GENERAL_ERROR" "Cannot create unique backup filename for $path"
    fi
  done

  log "Backing up $path to $backup"

  if [[ $dry_run_flag -eq 0 ]]; then
    if ! mv "$path" "$backup"; then
      die "$EXIT_GENERAL_ERROR" "Failed to create backup: $backup"
    fi

    # Verify backup was created
    if [[ ! -e "$backup" ]]; then
      die "$EXIT_GENERAL_ERROR" "Backup file does not exist after move: $backup"
    fi

    log_debug "Backup verified: $backup"
  fi
}

# ============================================================================
# CONFIGURATION FILE OPERATIONS
# ============================================================================

write_config() {
  local dest="$1"
  local dry_run_flag=$2
  local force_flag=$3

  local payload
  payload=$(config_payload)

  # Validate XML before writing
  if ! validate_xml "$payload"; then
    die "$EXIT_VALIDATION_FAILED" "Generated XML configuration is invalid"
  fi

  if [[ -f "$dest" ]]; then
    if diff -q <(echo "$payload") "$dest" >/dev/null 2>&1; then
      log "Configuration already up to date at $dest"
      return 0
    fi
    maybe_backup "$dest" "$dry_run_flag" "$force_flag"
  else
    if [[ $dry_run_flag -eq 1 ]]; then
      log "Dry run: would create $dest"
    else
      log "Creating $dest"
    fi
  fi

  if [[ $dry_run_flag -eq 0 ]]; then
    local tmp
    tmp=$(mktemp) || die "$EXIT_GENERAL_ERROR" "Failed to create temporary file"
    CLEANUP_FILES+=("$tmp")

    # Write config to temp file
    if ! echo "$payload" > "$tmp"; then
      die "$EXIT_GENERAL_ERROR" "Failed to write configuration to temporary file"
    fi

    # Verify temp file is not empty
    if [[ ! -s "$tmp" ]]; then
      die "$EXIT_GENERAL_ERROR" "Temporary configuration file is empty"
    fi

    # Set proper permissions before installing
    chmod 0644 "$tmp" || die "$EXIT_GENERAL_ERROR" "Failed to set permissions on temporary file"

    # Atomic install (preserves permissions)
    local dest_dir
    dest_dir="$(dirname "$dest")"

    if ! install -m 0644 "$tmp" "$dest"; then
      die "$EXIT_GENERAL_ERROR" "Failed to install configuration to $dest"
    fi

    # Verify installation
    if [[ ! -f "$dest" ]]; then
      die "$EXIT_GENERAL_ERROR" "Configuration file not found after installation: $dest"
    fi

    # Clean up temp file immediately after successful install
    rm -f "$tmp"
    CLEANUP_FILES=("${CLEANUP_FILES[@]/$tmp}")

    log_debug "Configuration written successfully to $dest"
  fi
}

# ============================================================================
# SYMLINK OPERATIONS
# ============================================================================

ensure_symlink() {
  local link_path="$1"
  local target_path="$2"
  local dry_run_flag=$3
  local force_flag=$4

  check_path_safety "$link_path" || die "$EXIT_VALIDATION_FAILED" "Unsafe link path"
  check_path_safety "$target_path" || die "$EXIT_VALIDATION_FAILED" "Unsafe target path"

  if [[ -L "$link_path" ]]; then
    local resolved
    resolved=$(readlink -f "$link_path" 2>/dev/null || true)
    local canonical
    canonical=$(readlink -f "$target_path" 2>/dev/null || true)

    if [[ "$resolved" == "$canonical" ]]; then
      log "Symlink already correct at $link_path"
      return 0
    fi

    if [[ $force_flag -eq 0 ]]; then
      die "$EXIT_GENERAL_ERROR" "Refusing to replace existing symlink $link_path (use --force). Points to: $resolved"
    fi

    log "Replacing conflicting symlink $link_path"
    if [[ $dry_run_flag -eq 0 ]]; then
      rm -f "$link_path" || die "$EXIT_GENERAL_ERROR" "Failed to remove existing symlink: $link_path"
    fi
  elif [[ -e "$link_path" ]]; then
    if [[ -d "$link_path" ]]; then
      die "$EXIT_GENERAL_ERROR" "$link_path is a directory; refusing to replace"
    fi

    if [[ $force_flag -eq 0 ]]; then
      die "$EXIT_GENERAL_ERROR" "Existing file at $link_path (use --force to replace)."
    fi

    maybe_backup "$link_path" "$dry_run_flag" "$force_flag"

    if [[ $dry_run_flag -eq 0 ]]; then
      rm -f "$link_path" || die "$EXIT_GENERAL_ERROR" "Failed to remove existing file: $link_path"
    fi
  fi

  if [[ $dry_run_flag -eq 1 ]]; then
    log "Dry run: would link $link_path -> $target_path"
  else
    log "Linking $link_path -> $target_path"

    if ! ln -s "$target_path" "$link_path"; then
      die "$EXIT_GENERAL_ERROR" "Failed to create symlink: $link_path -> $target_path"
    fi

    # Verify symlink was created
    if [[ ! -L "$link_path" ]]; then
      die "$EXIT_GENERAL_ERROR" "Symlink not found after creation: $link_path"
    fi

    log_debug "Symlink created and verified"
  fi
}

is_config_active() {
  local link_path="$1"
  local target_path="$2"

  [[ -L "$link_path" ]] || return 1

  local resolved
  resolved=$(readlink -f "$link_path" 2>/dev/null || true)
  local canonical
  canonical=$(readlink -f "$target_path" 2>/dev/null || true)

  [[ -n "$resolved" && -n "$canonical" && "$resolved" == "$canonical" ]]
}

# ============================================================================
# CONFIGURATION REMOVAL
# ============================================================================

remove_config() {
  local avail_path="$1"
  local link_path="$2"
  local dry_run_flag=$3

  local removed_something=0

  if is_config_active "$link_path" "$avail_path"; then
    if [[ $dry_run_flag -eq 1 ]]; then
      log "Dry run: would remove symlink $link_path"
    else
      log "Removing symlink $link_path"
      if ! rm -f "$link_path"; then
        log_error "Failed to remove symlink: $link_path"
      else
        removed_something=1
      fi
    fi
  elif [[ -L "$link_path" ]]; then
    log "Skipping $link_path (points elsewhere)"
  fi

  if [[ -f "$avail_path" ]]; then
    local payload
    payload=$(config_payload)

    if diff -q <(echo "$payload") "$avail_path" >/dev/null 2>&1; then
      if [[ $dry_run_flag -eq 1 ]]; then
        log "Dry run: would remove $avail_path"
      else
        log "Removing $avail_path"
        if ! rm -f "$avail_path"; then
          log_error "Failed to remove configuration file: $avail_path"
        else
          removed_something=1
        fi
      fi
    else
      log "Skipping $avail_path (contents differ from managed config)"
    fi
  fi

  if [[ $dry_run_flag -eq 0 && $removed_something -eq 1 ]]; then
    log "Configuration removed successfully"
  elif [[ $dry_run_flag -eq 0 && $removed_something -eq 0 ]]; then
    log "No managed configuration found to remove"
  fi
}

# ============================================================================
# FONT CACHE OPERATIONS
# ============================================================================

refresh_cache() {
  local dry_run_flag=$1
  local target_scope=$2

  if [[ $dry_run_flag -eq 1 ]]; then
    log "Dry run: skipping fc-cache"
    return
  fi

  if ! check_command fc-cache 0; then
    log_warn "fc-cache not found; skipping cache refresh. Install fontconfig package."
    return
  fi

  log "Refreshing font cache..."

  local cache_opts="-f"
  if [[ "$target_scope" == "user" ]]; then
    cache_opts="$cache_opts --user"
  fi

  if fc-cache $cache_opts 2>&1 | grep -q "failed\|error"; then
    log_warn "fc-cache reported issues, but continuing"
  else
    log "Font cache refreshed successfully"
  fi
}

# ============================================================================
# FONT DETECTION AND INSTALLATION
# ============================================================================

font_installed() {
  local face="$1"

  if ! check_command fc-list 0; then
    log_debug "fc-list not available for font checking"
    return 1
  fi

  local count
  count=$(fc-list "$face" 2>/dev/null | wc -l | tr -d ' \n\t')

  if [[ "${count:-0}" -gt 0 ]]; then
    log_debug "Font found: $face ($count matches)"
    return 0
  else
    log_debug "Font not found: $face"
    return 1
  fi
}

detect_package_manager() {
  # Try to detect package manager with priority
  if command -v pacman >/dev/null 2>&1; then
    echo "pacman"
  elif command -v apt-get >/dev/null 2>&1 || command -v apt >/dev/null 2>&1; then
    echo "apt"
  elif command -v dnf >/dev/null 2>&1; then
    echo "dnf"
  elif command -v yum >/dev/null 2>&1; then
    echo "yum"
  elif command -v zypper >/dev/null 2>&1; then
    echo "zypper"
  elif command -v emerge >/dev/null 2>&1; then
    echo "emerge"
  elif command -v apk >/dev/null 2>&1; then
    echo "apk"
  else
    echo "unknown"
  fi
}

install_fonts_if_needed() {
  local target_scope="$1"
  local dry_run_flag=$2
  local skip_install=$3

  local missing=()
  for face in "${REQUIRED_FONTS[@]}"; do
    if ! font_installed "$face"; then
      missing+=("$face")
    fi
  done

  if [[ ${#missing[@]} -eq 0 ]]; then
    log "All required fonts are already installed"
    return 0
  fi

  log_warn "Missing fonts detected: ${missing[*]}"

  if [[ $skip_install -eq 1 ]]; then
    log "Font installation skipped due to --no-font-install"
    log "Please install these fonts manually for best results"
    return 0
  fi

  if [[ $dry_run_flag -eq 1 ]]; then
    log "Dry run: would attempt to install required Noto font packages"
    return 0
  fi

  if [[ ${EUID:-$(id -u)} -ne 0 ]]; then
    log_warn "Not running as root; cannot auto-install font packages"
    log "Please install the missing fonts manually or re-run with sudo"
    return 0
  fi

  local mgr
  mgr=$(detect_package_manager)

  log "Detected package manager: $mgr"

  case "$mgr" in
    pacman)
      local pkg_list=("noto-fonts" "noto-fonts-cjk" "noto-fonts-extra")
      log "Installing packages: ${pkg_list[*]}"
      if pacman -S --needed --noconfirm "${pkg_list[@]}"; then
        log "Font packages installed successfully"
      else
        log_error "Package installation failed"
        return 1
      fi
      ;;
    apt)
      local pkg_list=("fonts-noto-core" "fonts-noto-color-emoji" "fonts-noto-unhinted")
      log "Updating package lists..."
      apt-get update -qq || log_warn "apt-get update had issues"
      log "Installing packages: ${pkg_list[*]}"
      if apt-get install -y "${pkg_list[@]}"; then
        log "Font packages installed successfully"
      else
        log_error "Package installation failed"
        return 1
      fi
      ;;
    dnf|yum)
      local pkg_list=(
        "google-noto-sans-fonts"
        "google-noto-serif-fonts"
        "google-noto-sans-thai-fonts"
        "google-noto-emoji-color-fonts"
        "google-noto-mono-fonts"
      )
      log "Installing packages: ${pkg_list[*]}"
      if $mgr install -y "${pkg_list[@]}"; then
        log "Font packages installed successfully"
      else
        log_error "Package installation failed"
        return 1
      fi
      ;;
    zypper)
      local pkg_list=(
        "google-noto-sans-fonts"
        "google-noto-serif-fonts"
        "google-noto-sans-thai-fonts"
        "google-noto-emoji-color-fonts"
        "google-noto-mono-fonts"
      )
      log "Installing packages: ${pkg_list[*]}"
      if zypper --non-interactive install --auto-agree-with-licenses "${pkg_list[@]}"; then
        log "Font packages installed successfully"
      else
        log_error "Package installation failed"
        return 1
      fi
      ;;
    emerge)
      local pkg_list=("media-fonts/noto" "media-fonts/noto-emoji")
      log "Installing packages: ${pkg_list[*]}"
      if emerge --ask=n --quiet "${pkg_list[@]}"; then
        log "Font packages installed successfully"
      else
        log_error "Package installation failed"
        return 1
      fi
      ;;
    apk)
      local pkg_list=("font-noto" "font-noto-emoji" "font-noto-thai")
      log "Installing packages: ${pkg_list[*]}"
      if apk add --no-cache "${pkg_list[@]}"; then
        log "Font packages installed successfully"
      else
        log_error "Package installation failed"
        return 1
      fi
      ;;
    *)
      log_warn "Package manager not detected or not supported"
      log "Please install the missing Noto fonts manually"
      log "Required fonts: ${missing[*]}"
      return 0
      ;;
  esac
}

# ============================================================================
# FLATPAK INTEGRATION
# ============================================================================

apply_flatpak_override() {
  local dry_run_flag=$1
  local target_scope=$2

  if [[ $target_scope != "user" ]]; then
    log_warn "--flatpak is only supported with --user installs; skipping"
    return 0
  fi

  if ! check_command flatpak 0; then
    log_warn "flatpak command not found; skipping Flatpak override"
    return 0
  fi

  local override_cmd=(
    flatpak override --user
    --filesystem=xdg-config/fontconfig:ro
    --filesystem=xdg-data/fonts:ro
  )

  if [[ $dry_run_flag -eq 1 ]]; then
    log "Dry run: would run: ${override_cmd[*]}"
    return 0
  fi

  log "Applying Flatpak override to expose host fontconfig and fonts..."

  if "${override_cmd[@]}" 2>&1; then
    log "Flatpak override applied successfully"
    log "Flatpak apps will now see your fontconfig and fonts"
  else
    log_error "Failed to apply Flatpak override"
    return 1
  fi
}

# ============================================================================
# STATUS REPORTING
# ============================================================================

report_status() {
  local avail_path="$1"
  local link_path="$2"
  local target="$3"

  echo "=== Configuration Status (${target}) ==="
  echo

  local payload
  payload=$(config_payload)

  # Check config file
  if [[ -f "$avail_path" ]] && diff -q <(echo "$payload") "$avail_path" >/dev/null 2>&1; then
    echo "✓ Config file: Present and correct"
    echo "  Location: $avail_path"
  elif [[ -f "$avail_path" ]]; then
    echo "⚠ Config file: Present but modified"
    echo "  Location: $avail_path"
  else
    echo "✗ Config file: Not found"
    echo "  Expected: $avail_path"
  fi

  echo

  # Check symlink
  if is_config_active "$link_path" "$avail_path"; then
    echo "✓ Symlink: Active and correct"
    echo "  Location: $link_path"
  elif [[ -L "$link_path" ]]; then
    local actual_target
    actual_target=$(readlink "$link_path")
    echo "⚠ Symlink: Points elsewhere"
    echo "  Location: $link_path"
    echo "  Points to: $actual_target"
  elif [[ -e "$link_path" ]]; then
    echo "⚠ Non-symlink entry present"
    echo "  Location: $link_path"
  else
    echo "✗ Symlink: Not found"
    echo "  Expected: $link_path"
  fi

  echo

  # Check fonts
  echo "Font status:"
  local all_present=1
  for font in "${REQUIRED_FONTS[@]}"; do
    if font_installed "$font"; then
      echo "  ✓ $font"
    else
      echo "  ✗ $font (missing)"
      all_present=0
    fi
  done

  echo

  if [[ $all_present -eq 1 ]] && is_config_active "$link_path" "$avail_path"; then
    echo "Status: Fully configured and active ✓"
    return 0
  elif is_config_active "$link_path" "$avail_path"; then
    echo "Status: Active but some fonts missing ⚠"
    return 0
  else
    echo "Status: Not active or incomplete ✗"
    return 1
  fi
}

# ============================================================================
# MAIN LOGIC
# ============================================================================

main() {
  local mode="install"
  local target="system"
  local dry_run=0
  local refresh=1
  local force=0
  local skip_font_install=0
  local configure_flatpak=0

  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --install)
        mode="install"
        shift
        ;;
      --remove)
        mode="remove"
        shift
        ;;
      --status)
        mode="status"
        shift
        ;;
      --system)
        target="system"
        shift
        ;;
      --user)
        target="user"
        shift
        ;;
      --dry-run)
        dry_run=1
        shift
        ;;
      --no-cache)
        refresh=0
        shift
        ;;
      --force)
        force=1
        shift
        ;;
      --no-font-install)
        skip_font_install=1
        shift
        ;;
      --flatpak)
        configure_flatpak=1
        shift
        ;;
      --debug)
        DEBUG=1
        shift
        ;;
      -h|--help)
        usage
        exit "$EXIT_SUCCESS"
        ;;
      --)
        shift
        break
        ;;
      -*)
        die "$EXIT_GENERAL_ERROR" "Unknown option: $1" "Run '$SCRIPT_NAME --help' for usage."
        ;;
      *)
        die "$EXIT_GENERAL_ERROR" "Unexpected argument: $1" "Run '$SCRIPT_NAME --help' for usage."
